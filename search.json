[{"path":"https://docs.ropensci.org/sodium/articles/crypto101.html","id":"the-xor-operator","dir":"Articles","previous_headings":"","what":"The XOR operator","title":"How does cryptography work?","text":"bitwise XOR operator outputs true inputs differ (one true, false). sometimes called invertor output bit x gets inverted corresponding bit y true: cryptography xor message x secret random data y. bit y randomly true probability 0.5, xor output completely random uncorrelated x. called perfect secrecy. know y can decipher message x. method perfectly secure forms basis cryptograhpic methods. However challenge generating communicating unique pseudo-random y data every time want encrypt something. One-time-pads example practical large messages. Also never re-use one-time-pad y encrypting multiple messages, compromises secrecy.","code":"# XOR two (8bit) bytes 'x' and 'y' x <- as.raw(0x7a) y <- as.raw(0xe4) z <- base::xor(x, y) dput(z) as.raw(0x9e) # Show the bits in each byte cbind(x = rawToBits(x), y = rawToBits(y), z = rawToBits(z)) x  y  z [1,] 00 00 00 [2,] 01 00 01 [3,] 00 01 01 [4,] 01 00 01 [5,] 01 00 01 [6,] 01 01 00 [7,] 01 01 00 [8,] 00 01 01 # Encrypt message using random one-time-pad msg <- charToRaw(\"TTIP is evil\") one_time_pad <- random(length(msg)) ciphertext <- base::xor(msg, one_time_pad)  # It's really encrypted rawToChar(ciphertext) [1] \"P@\\016\\xdd\\xe9\\xe7\\032g?=\\xaa\\021\" # Decrypt with same pad rawToChar(base::xor(ciphertext, one_time_pad)) [1] \"TTIP is evil\""},{"path":"https://docs.ropensci.org/sodium/articles/crypto101.html","id":"stream-ciphers","dir":"Articles","previous_headings":"","what":"Stream ciphers","title":"How does cryptography work?","text":"solution problem stream ciphers. stream cipher generates unique stream pseudo-random data based secret key unique nonce. given set parameters stream cipher always generates stream data. Sodium implements popular stream ciphers: stream requires key nonce. key forms shared secret known trusted parties. nonce secret stored sent along ciphertext. purpose nonce make random stream unique protect gainst re-use attacks. way can re-use key encrypt multiple messages, long never re-use nonce. years cryptographers come many variants. Many stream ciphers based block cipher AES: keyed permutation fixed length amount data. block ciphers get chained particular mode operation repeatedly applies cipher’s single-block operation securely transform amounts data larger block. going discuss implementation details, probably come something . example use hash function sha256 block cipher append counter incremented block (called CTR mode). allows us generate arbitrary length stream single secret key: practice, never write ciphers. lot research goes studying properties block ciphers various modes operation. remainder just use standard Sodium ciphers: chacha20, salsa20 xsalsa20.","code":"password <- \"My secret passphrase\" key <- hash(charToRaw(password)) nonce <- random(8) chacha20(size = 20, key, nonce) [1] 9f d1 10 3c 51 52 79 5e 43 1e d6 41 06 ae 06 7e f3 6f 80 ae salsa20(size = 20, key, nonce) [1] d7 26 a7 98 ec d0 56 97 54 f7 e8 92 29 84 ed aa 25 d6 28 93 # Illustrative example. sha256_ctr <- function(size, key, nonce){   n <- ceiling(size/32)   output <- raw()   for(i in 1:n){     counter <- packBits(intToBits(i))     block <- sha256(c(key, nonce, counter))     output <- c(output, block)   }   return(output[1:size]) } password <- \"My secret passphrase\" key <- hash(charToRaw(password)) nonce <- random(8) sha256_ctr(50, key, nonce) [1] a3 9a e2 79 11 b1 17 b6 e8 ac a3 d2 10 99 1b 55 9b fc 50 aa a0 ac e0 05 1f [26] f7 c4 91 b3 da e5 bd e6 1e 79 24 1f 25 61 d9 d1 98 95 43 53 00 15 96 73 15"},{"path":"https://docs.ropensci.org/sodium/articles/crypto101.html","id":"symmetric-encryption","dir":"Articles","previous_headings":"","what":"Symmetric encryption","title":"How does cryptography work?","text":"Symmetric encryption means secret key used encryption decryption. needed implement symmetric encryption xor stream cipher. example encrypt arbitrary length message using password: hash function converts password key suitable size stream cipher, use generate psuedo random stream equal length message: Now ciphertext encrypted version message. know key nonce can re-generate keystream order xor ciphertext back original message. Sodium functions data_encrypt data_decrypt provide elaborate implementation . use practice secret key encryption. Symmetric encryption can used e.g. encrypting local data. However secret used encryption decryption, impractical communication parties. exchanging secure messages need public key encryption.","code":"# Encrypt 'message' using 'password' myfile <- file.path(R.home(), \"COPYING\") message <- readBin(myfile, raw(), file.info(myfile)$size) passwd <- charToRaw(\"My secret passphrase\") # Basic secret key encryption key <- hash(passwd) nonce8 <- random(8) stream <- chacha20(length(message), key, nonce8) ciphertext <- base::xor(stream, message) # Decrypt with the same key key <- hash(charToRaw(\"My secret passphrase\")) stream <- chacha20(length(ciphertext), key, nonce8) out <- base::xor(ciphertext, stream)  # Print part of the message cat(substring(rawToChar(out), 1, 120)) GNU GENERAL PUBLIC LICENSE                        Version 2, June 1991   Copyright (C) 1989, 1991 Fr"},{"path":"https://docs.ropensci.org/sodium/articles/crypto101.html","id":"public-key-encryption-and-diffie-hellman","dir":"Articles","previous_headings":"","what":"Public-key encryption and Diffie-Hellman","title":"How does cryptography work?","text":"Rather using single secret-key, assymetric (public key) encryption requires keypair, consisting public key encryption private-key decryption. Data encrypted using given public key can decrypted using corresponding private key. public key confidential can shared e.g. website keyserver. allows anyone send somebody secure message encrypting receivers public key. encrypted message readable owner corresponding private key. work? Public key encryption makes use Diffie-Hellman (D-H): method allows two parties prior knowledge jointly establish shared secret key insecure channel. simple case, parties generate temporary keypair exchange public key insecure channel. parties use D-H function calculcate () shared secret key combining private key person’s public key: shared secret established, parties can discard temporary public/private key use shared secret start encrypting communications symmetric encryption discussed earlier. shared secret calculated using public keys, process safe eavesdroppers. classical Diffie-Hellman method based discrete logarithm problem large prime numbers. Sodium uses curve25519, state---art D-H function Daniel Bernsteinan designed use elliptic curve Diffie–Hellman (ECDH) key agreement scheme.","code":"# Create keypair key <- keygen() pub <- pubkey(key)  # Encrypt message for receiver using his/her public key msg <- serialize(iris, NULL) ciphertext <- simple_encrypt(msg, pub)  # Receiver decrypts with his/her private key out <- simple_decrypt(ciphertext, key) identical(msg, out) [1] TRUE # Bob generates keypair bob_key <- keygen() bob_pubkey <- pubkey(bob_key)  # Alice generates keypair alice_key <- keygen() alice_pubkey <- pubkey(alice_key)  # After Bob and Alice exchange pubkey they can both derive the secret alice_secret <- diffie_hellman(alice_key, bob_pubkey) bob_secret <- diffie_hellman(bob_key, alice_pubkey) identical(alice_secret, bob_secret) [1] TRUE"},{"path":"https://docs.ropensci.org/sodium/articles/intro.html","id":"using-sodium","dir":"Articles","previous_headings":"","what":"Using Sodium","title":"Sodium: A Modern and Easy-to-Use Crypto Library","text":"Sodium functions operate binary data, called ‘raw’ vectors R. Use charToRaw rawToChar convert strings raw vectors. Alternatively hex2bin bin2hex can convert binary data strings hex notation:","code":"test <- hash(charToRaw(\"test 123\")) str <- bin2hex(test) print(str) [1] \"e8b785b02e702c0b7edc9683130db36c91e0241ba0c489ff1e20cbb4fa3920f9\" hex2bin(str) [1] e8 b7 85 b0 2e 70 2c 0b 7e dc 96 83 13 0d b3 6c 91 e0 24 1b a0 c4 89 ff 1e [26] 20 cb b4 fa 39 20 f9"},{"path":"https://docs.ropensci.org/sodium/articles/intro.html","id":"random-data-generator","dir":"Articles","previous_headings":"","what":"Random data generator","title":"Sodium: A Modern and Easy-to-Use Crypto Library","text":"random() function generates n bytes unpredictable data, suitable creating secret keys. Implementation platform specific, see docs details.","code":"secret <- random(8) print(secret) [1] 09 c5 b5 ed 7e 11 d3 14"},{"path":"https://docs.ropensci.org/sodium/articles/intro.html","id":"hash-functions","dir":"Articles","previous_headings":"","what":"Hash functions","title":"Sodium: A Modern and Easy-to-Use Crypto Library","text":"Sodium several hash functions including hash(), shorthash(), sha256(), sha512 scrypt(). generic hash() usually recommended. uses blake2b configurable size 16 bytes (128bit) 64 bytes (512bit). shorthash() function special 8 byte (64 bit) hash based SipHash-2-4. output function 64 bits (8 bytes). useful e.g. Hash tables, considered collision-resistant.","code":"# Generate keys from passphrase passphrase <- charToRaw(\"This is super secret\") hash(passphrase) [1] 98 5c 9b b6 f6 92 d5 26 10 80 99 25 3e a5 a6 66 67 13 fd 88 10 b6 12 74 86 [26] c8 e9 5c 44 07 45 f5 hash(passphrase, size = 16) [1] eb 6c df 04 18 40 16 28 c1 b0 2e 76 f3 e6 bd 89 hash(passphrase, size = 64) [1] d0 89 68 30 26 1d 1b 85 76 dc ad 20 c9 58 0a fb b1 d0 62 ba 10 d6 80 f6 cb [26] c6 ae 2d 42 57 ee a0 65 fd b0 e8 90 02 ae b3 e0 4f 88 df ba ea 26 bb 47 3f [51] 29 5a a4 06 cd b8 05 78 83 31 66 dc 7b 24"},{"path":"https://docs.ropensci.org/sodium/articles/intro.html","id":"secret-key-encryption","dir":"Articles","previous_headings":"","what":"Secret key encryption","title":"Sodium: A Modern and Easy-to-Use Crypto Library","text":"Symmetric encryption uses secret key encryption decryption. mainly useful encrypting local data, building block complex methods. encryption methods require nonce: piece non-secret unique data used randomize cipher. allows safely using key encrypting multiple messages. nonce stored shared along ciphertext. secret known parties, symmetric encryption often impractical communication third parties. need asymmetric (public key) methods.","code":"key <- hash(charToRaw(\"This is a secret passphrase\")) msg <- serialize(iris, NULL)  # Encrypt with a random nonce nonce <- random(24) cipher <- data_encrypt(msg, key, nonce)  # Decrypt with same key and nonce orig <- data_decrypt(cipher, key, nonce) identical(iris, unserialize(orig)) [1] TRUE"},{"path":"https://docs.ropensci.org/sodium/articles/intro.html","id":"secret-key-authentication","dir":"Articles","previous_headings":"","what":"Secret key authentication","title":"Sodium: A Modern and Easy-to-Use Crypto Library","text":"Secret key authentication called tagging Sodium. tag basically hash data together secret key. verify integrity data later point time, simply re-calculate tag key: secret key protects forgery data+tag intermediate party, possible regular checksum.","code":"key <- hash(charToRaw(\"This is a secret passphrase\")) msg <- serialize(iris, NULL) mytag <- data_tag(msg, key) stopifnot(identical(mytag, data_tag(msg, key)))"},{"path":"https://docs.ropensci.org/sodium/articles/intro.html","id":"public-key-encryption","dir":"Articles","previous_headings":"","what":"Public key encryption","title":"Sodium: A Modern and Easy-to-Use Crypto Library","text":"symmetric methods use secret key encryption decryption, asymmetric methods use key-pair consisting public key private key. private key secret known owner. public key hand can shared anyone. Public keys often published user’s website posted public directories keyservers. public key encryption, data encrypted public key can decrypted using corresponding private key. allows anyone send somebody secure message encrypting receivers public key. encrypted message readable owner corresponding private key.","code":"key <- keygen() pub <- pubkey(key) # Encrypt message with pubkey msg <- serialize(iris, NULL) ciphertext <- simple_encrypt(msg, pub)  # Decrypt message with private key out <- simple_decrypt(ciphertext, key) stopifnot(identical(out, msg))"},{"path":"https://docs.ropensci.org/sodium/articles/intro.html","id":"public-key-authentication-signatures","dir":"Articles","previous_headings":"","what":"Public key authentication (signatures)","title":"Sodium: A Modern and Easy-to-Use Crypto Library","text":"Public key authentication works way around. First, owner private key creates ‘signature’ (authenticated checksum) message way allows anyone knows /public key verify integrity message identity sender. Currently sodium requires different type key-pair signatures (ed25519) encryption (curve25519). Signatures useful message confidential integrity important. common use software repositories include index file checksums packages, signed repository maintainer. allows client package managers verify binaries manipulated intermediate parties distribution process.","code":"# Generate signature keypair key <- sig_keygen() pubkey <- sig_pubkey(key)  # Create signature with private key msg <- serialize(iris, NULL) sig <- sig_sign(msg, key) print(sig) [1] 62 49 b8 42 15 76 82 48 62 02 85 0d a5 ae 08 47 5b 98 e1 dc 8e 4d 34 d5 67 [26] 1b 4c d9 6f 9e f9 6f 10 d6 26 25 c7 bd 34 cb f3 bb c9 49 ab 0b a2 e8 4e f1 [51] 98 fb 1b fb fa 6e 1f c5 e1 df 4a 23 e9 04 # Verify a signature from public key sig_verify(msg, sig, pubkey) [1] TRUE"},{"path":"https://docs.ropensci.org/sodium/articles/intro.html","id":"public-key-authenticated-encryption","dir":"Articles","previous_headings":"","what":"Public key authenticated encryption","title":"Sodium: A Modern and Easy-to-Use Crypto Library","text":"Authenticated encryption implements best practices secure messaging. requires sender receiver keypair know ’s public key. message gets authenticated key sender encrypted key receiver. Note even though public keys confidential, exchange insecure channel trying protect. connection tampered , attacker simply replace key another one hijack interaction.","code":"# Bob's keypair: bob_key <- keygen() bob_pubkey <- pubkey(bob_key)  # Alice's keypair: alice_key <- keygen() alice_pubkey <- pubkey(alice_key)  # Bob sends encrypted message for Alice: msg <- charToRaw(\"TTIP is evil\") ciphertext <- auth_encrypt(msg, bob_key, alice_pubkey)  # Alice verifies and decrypts with her key out <- auth_decrypt(ciphertext, alice_key, bob_pubkey) stopifnot(identical(out, msg))  # Alice sends encrypted message for Bob msg <- charToRaw(\"Let's protest\") ciphertext <- auth_encrypt(msg, alice_key, bob_pubkey)  # Bob verifies and decrypts with his key out <- auth_decrypt(ciphertext, bob_key, alice_pubkey) stopifnot(identical(out, msg))"},{"path":"https://docs.ropensci.org/sodium/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Jeroen Ooms. Author, maintainer.","code":""},{"path":"https://docs.ropensci.org/sodium/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Ooms J (2024). sodium: Modern Easy--Use Crypto Library. R package version 1.3.1, https://docs.ropensci.org/sodium/https://github.com/r-lib/sodium.","code":"@Manual{,   title = {sodium: A Modern and Easy-to-Use Crypto Library},   author = {Jeroen Ooms},   year = {2024},   note = {R package version 1.3.1},   url = {https://docs.ropensci.org/sodium/ https://github.com/r-lib/sodium}, }"},{"path":"https://docs.ropensci.org/sodium/index.html","id":"sodium","dir":"","previous_headings":"","what":"A Modern and Easy-to-Use Crypto Library","title":"A Modern and Easy-to-Use Crypto Library","text":"Modern Easy--Use Crypto Library  Bindings libsodium: modern, easy--use software library encryption, decryption, signatures, password hashing . Sodium uses curve25519, state---art Diffie-Hellman function Daniel Bernstein, become popular discovered NSA backdoored Dual EC DRBG.","code":""},{"path":"https://docs.ropensci.org/sodium/index.html","id":"documentation","dir":"","previous_headings":"","what":"Documentation","title":"A Modern and Easy-to-Use Crypto Library","text":"R package: Vignette: Introduction Sodium R Vignette: cryptography work resources: Sodium crypto library (libsodium)","code":""},{"path":"https://docs.ropensci.org/sodium/index.html","id":"hello-world","dir":"","previous_headings":"","what":"Hello World","title":"A Modern and Easy-to-Use Crypto Library","text":"","code":"# Generate keypair: key <- keygen() pub <- pubkey(key)  # Encrypt message with pubkey msg <- serialize(iris, NULL) ciphertext <- simple_encrypt(msg, pub)  # Decrypt message with private key out <- simple_decrypt(ciphertext, key)"},{"path":"https://docs.ropensci.org/sodium/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"A Modern and Easy-to-Use Crypto Library","text":"Binary packages OS-X Windows can installed directly CRAN: Installation source Linux OSX requires libsodium. Debian Ubuntu install libsodium-dev: Fedora need libsodium-devel: CentOS / RHEL install libsodium-devel via EPEL: OS-X use libsodium Homebrew:","code":"install.packages(\"sodium\") sudo apt-get install -y libsodium-dev sudo yum install libsodium-devel sudo yum install epel-release sudo yum install libsodium-devel brew install libsodium"},{"path":"https://docs.ropensci.org/sodium/reference/diffie.html","id":null,"dir":"Reference","previous_headings":"","what":"Diffie-Hellman — Diffie-Hellman","title":"Diffie-Hellman — Diffie-Hellman","text":"Diffie-Hellman key exchange method allows two parties prior knowledge jointly establish shared secret key insecure channel. key can used encrypt subsequent communications using symmetric key cipher.","code":""},{"path":"https://docs.ropensci.org/sodium/reference/diffie.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Diffie-Hellman — Diffie-Hellman","text":"","code":"diffie_hellman(key, pubkey)"},{"path":"https://docs.ropensci.org/sodium/reference/diffie.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Diffie-Hellman — Diffie-Hellman","text":"key private key pubkey person's public key","code":""},{"path":"https://docs.ropensci.org/sodium/reference/diffie.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Diffie-Hellman — Diffie-Hellman","text":"Returns shared secret key can used e.g. data_encrypt.","code":""},{"path":"https://docs.ropensci.org/sodium/reference/diffie.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Diffie-Hellman — Diffie-Hellman","text":"Encryption methods implemented data_encrypt require parties shared secret key. often wish establish secure channel party prior relationship . Diffie-hellman method jointly agreeing shared secret without ever exchanging secret . Sodium implements Curve25519, state---art Diffie-Hellman function suitable wide variety applications. method conists two steps (see examples). First, parties generate random private key derive corresponding public key using pubkey. public keys confidential can exchanged insecure channel. public keys exchanged, parties able calculate () shared secret combining /private key person's public key using diffie_hellman. shared secret established, private public keys disposed, parties can start encrypting communications based shared secret using e.g. data_encrypt. shared secret calculated using public keys, process safe eavesdroppers.","code":""},{"path":"https://docs.ropensci.org/sodium/reference/diffie.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Diffie-Hellman — Diffie-Hellman","text":"https://doc.libsodium.org/advanced/scalar_multiplication.html","code":""},{"path":"https://docs.ropensci.org/sodium/reference/diffie.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Diffie-Hellman — Diffie-Hellman","text":"","code":"# Bob generates keypair bob_key <- keygen() bob_pubkey <- pubkey(bob_key)  # Alice generates keypair alice_key <- keygen() alice_pubkey <- pubkey(alice_key)  # After Bob and Alice exchange pubkey they can both derive the secret alice_secret <- diffie_hellman(alice_key, bob_pubkey) bob_secret <- diffie_hellman(bob_key, alice_pubkey) stopifnot(identical(alice_secret, bob_secret))"},{"path":"https://docs.ropensci.org/sodium/reference/hash.html","id":null,"dir":"Reference","previous_headings":"","what":"Hash Functions — Hash functions","title":"Hash Functions — Hash functions","text":"Functions calculate cryptographic hash message, optionally key HMAC applications. storing passwords, use password_store instead.","code":""},{"path":"https://docs.ropensci.org/sodium/reference/hash.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Hash Functions — Hash functions","text":"","code":"hash(buf, key = NULL, size = 32)  scrypt(buf, salt = raw(32), size = 32)  argon2(buf, salt = raw(16), size = 32)  shorthash(buf, key)  sha512(buf, key = NULL)  sha256(buf, key = NULL)"},{"path":"https://docs.ropensci.org/sodium/reference/hash.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Hash Functions — Hash functions","text":"buf data hashed key key HMAC hashing. Optional, except shorthash. size length output hash. Must 16 64 (recommended 32) salt non-confidential random data seed algorithm","code":""},{"path":"https://docs.ropensci.org/sodium/reference/hash.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Hash Functions — Hash functions","text":"generic hash function recommended applications. uses dynamic length BLAKE2b output size can value 16 bytes (128bit) 64 bytes (512bit). scrypt hash function designed CPU memory expensive protect brute force attacks. algorithm also used password_store function. argon2 hash function also designed CPU memory expensive protect brute force attacks. Argon2 password-hashing function summarizes state art design memory-hard functions shorthash function special 8 byte (64 bit) hash based SipHash-2-4. output function 64 bits (8 bytes). useful e.g. Hash tables, considered collision-resistant. Hash functions can used HMAC specifying secret key. key size shorthash 16 bytes, sha256 32 bytes sha512 64 bytes. hash key size can value 16 62, recommended least 32.","code":""},{"path":"https://docs.ropensci.org/sodium/reference/hash.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Hash Functions — Hash functions","text":"https://libsodium.gitbook.io/doc/hashing/generic_hashing","code":""},{"path":"https://docs.ropensci.org/sodium/reference/hash.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Hash Functions — Hash functions","text":"","code":"# Basic hashing msg <- serialize(iris, NULL) hash(msg) #>  [1] 59 21 a7 79 8e 53 0b 60 ad 4e 53 04 15 15 df 38 86 f1 97 42 0d 3b 4a be 40 #> [26] f5 e7 d4 66 c2 19 8c sha256(msg) #>  [1] d7 d7 0e 07 79 9f 8e ba ef 70 83 35 4f f9 ec a0 5b 77 ce d4 71 1e 49 be b0 #> [26] 47 6e 10 8e 19 c8 88 sha512(msg) #>  [1] 9b b2 b3 2e a7 ef 60 2c 31 76 69 90 02 1d 32 8c a1 e8 bb 77 b2 c6 00 0b 5e #> [26] 78 73 3a f8 f8 17 1c 9e 3e ef 29 24 3b 7b 39 8c c3 62 84 b6 08 62 4f 0a 1f #> [51] 72 c1 10 75 fe a5 11 76 66 d8 67 75 2e 0b scrypt(msg) #>  [1] 78 7e 51 07 44 e7 84 0e 57 bc d1 32 1e 72 0a 0b fd bc 5e 86 b2 0c 0d 64 c7 #> [26] 13 bb cb 11 d4 23 29  # Generate keys from passphrase passphrase <- charToRaw(\"This is super secret\") key <- hash(passphrase) shortkey <- hash(passphrase, size = 16) longkey <- hash(passphrase, size = 64)  # HMAC (hashing with key) hash(msg, key = key) #>  [1] 63 7d 4f 86 ec f4 43 fc 5c 3d 9d 54 28 78 9b de 47 02 d7 01 0a 12 e8 73 0f #> [26] 40 46 cd e0 e2 d9 b8 shorthash(msg, shortkey) #> [1] 03 cd cb 4c cf 5e 8f 7e sha256(msg, key = key) #>  [1] 20 e3 5f 2b 73 85 89 87 03 6a 7b 22 d7 88 e6 cc 68 d8 8d 3a d7 1d b5 4e fd #> [26] c0 e4 fd 38 c4 e8 33 sha512(msg, key = longkey) #>  [1] 95 83 e5 3b f9 8c 8b 6c de 51 74 9f 7d cc 60 f0 ae 6a ae 76 b6 91 d9 bd 02 #> [26] 96 7f 80 99 74 94 f8 0d 0a 11 12 12 91 15 de 88 f2 b8 c5 39 b6 aa e6 91 2e #> [51] 56 b7 a9 40 12 10 75 b8 64 00 4b 2a 8c db"},{"path":"https://docs.ropensci.org/sodium/reference/helpers.html","id":null,"dir":"Reference","previous_headings":"","what":"Sodium Utilities — Sodium utilities","title":"Sodium Utilities — Sodium utilities","text":"functions bin2hex hex2bin convert binary (raw) vectors corresponding string hexadecimal notation. random function generates n crypto secure random bytes.","code":""},{"path":"https://docs.ropensci.org/sodium/reference/helpers.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sodium Utilities — Sodium utilities","text":"","code":"bin2hex(bin)  hex2bin(hex, ignore = \":\")  random(n = 1)"},{"path":"https://docs.ropensci.org/sodium/reference/helpers.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sodium Utilities — Sodium utilities","text":"bin raw vector binary data convert hex string hex string hexadecimal characters parse binary (raw) vector. ignore string characters ignore hex. See example. n number random bytes numbers generate","code":""},{"path":"https://docs.ropensci.org/sodium/reference/helpers.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sodium Utilities — Sodium utilities","text":"","code":"# Convert raw to hex string and back test <- charToRaw(\"test 123\") x <- bin2hex(test) y <- hex2bin(x) stopifnot(identical(test, y)) stopifnot(identical(x, paste(test, collapse = \"\")))  # Parse text with characters x2 <- paste(test, collapse = \":\") y2 <- hex2bin(x2, ignore = \":\") stopifnot(identical(test, y2))"},{"path":"https://docs.ropensci.org/sodium/reference/keygen.html","id":null,"dir":"Reference","previous_headings":"","what":"Keypair Generation — Key generation","title":"Keypair Generation — Key generation","text":"Functions generate random private key calculate corresponding curve25519 public key.","code":""},{"path":"https://docs.ropensci.org/sodium/reference/keygen.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Keypair Generation — Key generation","text":"","code":"keygen(seed = random(32))  pubkey(key)"},{"path":"https://docs.ropensci.org/sodium/reference/keygen.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Keypair Generation — Key generation","text":"seed random data seed keygen key private key calculate public key","code":""},{"path":"https://docs.ropensci.org/sodium/reference/keygen.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Keypair Generation — Key generation","text":"Asymmetric methods rely public-private keypairs. private keys secret never shared anyone. public key hand confidential shared parties. Public keys typically published users's website posted public directories keyservers. two main applications public key cryptography encryption authentication. public key encryption, data encrypted using public key can decrypted using corresponding private key. allows anyone send somebody secure message encrypting receivers public key. encrypted message readable owner corresponding private key. Basic encryption implemented simple_encrypt. Authentication works way around. public key authentication, owner private key creates 'signature' (authenticated checksum) message way allows anyone knows user's public key verify message indeed signed owner private key. sender receiver know 's public key, two methods can combined message going back forth signed sender encrypted receiver. protects eavesdropping MITM tampering, creating fully secure channel.","code":""},{"path":"https://docs.ropensci.org/sodium/reference/keygen.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Keypair Generation — Key generation","text":"","code":"# Create keypair key <- keygen() pub <- pubkey(key)  # Basic encryption msg <- serialize(iris, NULL) ciphertext <- simple_encrypt(msg, pub) out <- simple_decrypt(ciphertext, key) stopifnot(identical(msg, out))"},{"path":"https://docs.ropensci.org/sodium/reference/messaging.html","id":null,"dir":"Reference","previous_headings":"","what":"Authenticated Encryption — Authenticated encryption","title":"Authenticated Encryption — Authenticated encryption","text":"Exchange secure messages curve25519 authenticated encryption.","code":""},{"path":"https://docs.ropensci.org/sodium/reference/messaging.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Authenticated Encryption — Authenticated encryption","text":"","code":"auth_encrypt(msg, key, pubkey, nonce = random(24))  auth_decrypt(bin, key, pubkey, nonce = attr(bin, \"nonce\"))"},{"path":"https://docs.ropensci.org/sodium/reference/messaging.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Authenticated Encryption — Authenticated encryption","text":"msg message encrypted key private key pubkey person's public key nonce non-secret unique data randomize cipher bin encrypted ciphertext generated secure_send","code":""},{"path":"https://docs.ropensci.org/sodium/reference/messaging.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Authenticated Encryption — Authenticated encryption","text":"Authenticated encryption implements best practices secure messaging. requires sender receiver keypair know 's public key. message gets authenticated key sender encrypted key receiver. Even though public keys confidential, exchange insecure channel trying protect. connection tampered , attacker simply replace key another one hijack interaction. people share public key posting website public keyserver. Another alternative public key signed mutually trusted third party. HTTPS using Certificate Authorities.","code":""},{"path":"https://docs.ropensci.org/sodium/reference/messaging.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Authenticated Encryption — Authenticated encryption","text":"https://libsodium.gitbook.io/doc/public-key_cryptography/authenticated_encryption","code":""},{"path":"https://docs.ropensci.org/sodium/reference/messaging.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Authenticated Encryption — Authenticated encryption","text":"","code":"# Bob's keypair: bob_key <- keygen() bob_pubkey <- pubkey(bob_key)  # Alice's keypair: alice_key <- keygen() alice_pubkey <- pubkey(alice_key)  # Bob sends encrypted message for Alice: msg <- charToRaw(\"TTIP is evil\") ciphertext <- auth_encrypt(msg, bob_key, alice_pubkey)  # Alice verifies and decrypts with her key out <- auth_decrypt(ciphertext, alice_key, bob_pubkey) stopifnot(identical(out, msg))  # Alice sends encrypted message for Bob msg <- charToRaw(\"Let's protest\") ciphertext <- auth_encrypt(msg, alice_key, bob_pubkey)  # Bob verifies and decrypts with his key out <- auth_decrypt(ciphertext, bob_key, alice_pubkey) stopifnot(identical(out, msg))"},{"path":"https://docs.ropensci.org/sodium/reference/password.html","id":null,"dir":"Reference","previous_headings":"","what":"Password Storage — Password storage","title":"Password Storage — Password storage","text":"Wrapper implements best practices storing passwords based scrypt random salt.","code":""},{"path":"https://docs.ropensci.org/sodium/reference/password.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Password Storage — Password storage","text":"","code":"password_store(password)  password_verify(hash, password)"},{"path":"https://docs.ropensci.org/sodium/reference/password.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Password Storage — Password storage","text":"password string length one password hash hash string length one generated password_store","code":""},{"path":"https://docs.ropensci.org/sodium/reference/password.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Password Storage — Password storage","text":"password_store function returns ASCII encoded string contains result memory-hard, CPU-intensive hash function along automatically generated salt parameters required verify password. Use password_verify verify password string.","code":""},{"path":"https://docs.ropensci.org/sodium/reference/password.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Password Storage — Password storage","text":"https://doc.libsodium.org/password_hashing/","code":""},{"path":"https://docs.ropensci.org/sodium/reference/password.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Password Storage — Password storage","text":"","code":"# Example password password <- \"I like cookies\"  # Hash is what you store in the database hash <- password_store(password)  # To verify the password when the user logs in stopifnot(password_verify(hash, password))"},{"path":"https://docs.ropensci.org/sodium/reference/sig.html","id":null,"dir":"Reference","previous_headings":"","what":"Create and Verify Signatures — Signatures","title":"Create and Verify Signatures — Signatures","text":"Cryptographic signatures can used verify integrity message using author's public key.","code":""},{"path":"https://docs.ropensci.org/sodium/reference/sig.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create and Verify Signatures — Signatures","text":"","code":"sig_sign(msg, key)  sig_verify(msg, sig, pubkey)  sig_keygen(seed = random(32))  sig_pubkey(key)"},{"path":"https://docs.ropensci.org/sodium/reference/sig.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create and Verify Signatures — Signatures","text":"msg message sign key private key sign message sig signature generated signature_sign pubkey public key keypair used signature seed random data seed keygen","code":""},{"path":"https://docs.ropensci.org/sodium/reference/sig.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create and Verify Signatures — Signatures","text":"signature authenticated checksum can used check message (data) created particular author tampered . signature created using private key can verified corresponding public key. Signatures used message confidential integrity important. common use software repositories maintainers include signature package index. allows client package managers verify binaries modified intermediate parties distribution process. confidential data, use authenticated encryption (auth_encrypt) allows sending signed encrypted messages single method. Currently sodium requires different type key pairfor signatures  (ed25519) encryption (curve25519).","code":""},{"path":"https://docs.ropensci.org/sodium/reference/sig.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Create and Verify Signatures — Signatures","text":"https://doc.libsodium.org/public-key_cryptography/public-key_signatures.html","code":""},{"path":"https://docs.ropensci.org/sodium/reference/sig.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create and Verify Signatures — Signatures","text":"","code":"# Generate keypair key <- sig_keygen() pubkey <- sig_pubkey(key)  # Create signature msg <- serialize(iris, NULL) sig <- sig_sign(msg, key) sig_verify(msg, sig, pubkey) #> [1] TRUE"},{"path":"https://docs.ropensci.org/sodium/reference/simple.html","id":null,"dir":"Reference","previous_headings":"","what":"Anonymous Public-key Encryption (Sealed Box) — Simple encryption","title":"Anonymous Public-key Encryption (Sealed Box) — Simple encryption","text":"Create encrypted message (sealed box) curve25519 public key.","code":""},{"path":"https://docs.ropensci.org/sodium/reference/simple.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Anonymous Public-key Encryption (Sealed Box) — Simple encryption","text":"","code":"simple_encrypt(msg, pubkey)  simple_decrypt(bin, key)"},{"path":"https://docs.ropensci.org/sodium/reference/simple.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Anonymous Public-key Encryption (Sealed Box) — Simple encryption","text":"msg message encrypted pubkey public key receiver bin encrypted ciphertext key private key receiver","code":""},{"path":"https://docs.ropensci.org/sodium/reference/simple.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Anonymous Public-key Encryption (Sealed Box) — Simple encryption","text":"Simple public key encryption allows sending anonymous encrypted messages recipient given public key. recipient can decrypt messages, using private key. recipient can verify integrity message, verify identity sender. sending authenticated encrypted messages, use auth_encrypt auth_decrypt.","code":""},{"path":"https://docs.ropensci.org/sodium/reference/simple.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Anonymous Public-key Encryption (Sealed Box) — Simple encryption","text":"https://doc.libsodium.org/public-key_cryptography/sealed_boxes.html","code":""},{"path":"https://docs.ropensci.org/sodium/reference/simple.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Anonymous Public-key Encryption (Sealed Box) — Simple encryption","text":"","code":"# Generate keypair key <- keygen() pub <- pubkey(key)  # Encrypt message with pubkey msg <- serialize(iris, NULL) ciphertext <- simple_encrypt(msg, pub)  # Decrypt message with private key out <- simple_decrypt(ciphertext, key) stopifnot(identical(out, msg))"},{"path":"https://docs.ropensci.org/sodium/reference/stream.html","id":null,"dir":"Reference","previous_headings":"","what":"Stream Ciphers — Stream ciphers","title":"Stream Ciphers — Stream ciphers","text":"Generate deterministic streams random data based secret key random nonce.","code":""},{"path":"https://docs.ropensci.org/sodium/reference/stream.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Stream Ciphers — Stream ciphers","text":"","code":"chacha20(size, key, nonce)  salsa20(size, key, nonce)  xsalsa20(size, key, nonce)"},{"path":"https://docs.ropensci.org/sodium/reference/stream.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Stream Ciphers — Stream ciphers","text":"size length cipher stream bytes key secret key used cipher nonce non-secret unique data randomize cipher","code":""},{"path":"https://docs.ropensci.org/sodium/reference/stream.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Stream Ciphers — Stream ciphers","text":"usually need call methods directly. local encryption use data_encrypt. secure communication use simple_encrypt auth_encrypt. Random streams form basis cryptographic methods. Based shared secret (key) generate predictable random data stream equal length message need encrypt. xor message data random stream, effectively inverts byte message probabiliy 0.5. message can decrypted re-generating exactly random data stream xor'ing back. See examples. stream generator requires key nonce. required re-generate stream decryption. key forms shared secret known trusted parties. nonce secret stored sent along ciphertext. purpose nonce make random stream unique protect gainst re-use attacks. way can re-use key encrypt multiple messages, long never re-use nonce.","code":""},{"path":"https://docs.ropensci.org/sodium/reference/stream.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Stream Ciphers — Stream ciphers","text":"https://libsodium.gitbook.io/doc/advanced/stream_ciphers/xsalsa20","code":""},{"path":"https://docs.ropensci.org/sodium/reference/stream.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Stream Ciphers — Stream ciphers","text":"","code":"# Very basic encryption myfile <- file.path(R.home(), \"COPYING\") message <- readBin(myfile, raw(), file.info(myfile)$size) passwd <- charToRaw(\"My secret passphrase\")  # Encrypt: key <- hash(passwd) nonce8 <- random(8) stream <- chacha20(length(message), key, nonce8) ciphertext <- base::xor(stream, message)  # Decrypt: stream <- chacha20(length(ciphertext), key, nonce8) out <- base::xor(ciphertext, stream) stopifnot(identical(out, message))  # Other stream ciphers stream <- salsa20(10000, key, nonce8) stream <- xsalsa20(10000, key, random(24))"},{"path":"https://docs.ropensci.org/sodium/reference/symmetric.html","id":null,"dir":"Reference","previous_headings":"","what":"Symmetric Encryption and Tagging — Symmetric encryption","title":"Symmetric Encryption and Tagging — Symmetric encryption","text":"Encryption authentication using 256 bit shared secret. Mainly useful encrypting local data. secure communication use public-key encryption (simple_encrypt auth_encrypt).","code":""},{"path":"https://docs.ropensci.org/sodium/reference/symmetric.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Symmetric Encryption and Tagging — Symmetric encryption","text":"","code":"data_encrypt(msg, key, nonce = random(24))  data_decrypt(bin, key, nonce = attr(bin, \"nonce\"))  data_tag(msg, key)"},{"path":"https://docs.ropensci.org/sodium/reference/symmetric.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Symmetric Encryption and Tagging — Symmetric encryption","text":"msg message encrypted key shared secret key used encryption decryption nonce non-secret unique data randomize cipher bin encrypted ciphertext","code":""},{"path":"https://docs.ropensci.org/sodium/reference/symmetric.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Symmetric Encryption and Tagging — Symmetric encryption","text":"Symmetric encryption uses secret key encode decode message. can used encrypt local data disk, building block complex methods. secret used encryption decryption, symmetric encryption impractical communication. exchanging secure messages parties, use assymetric (public-key) methods (see simple_encrypt auth_encrypt). nonce confidential required decryption, stored sent along ciphertext. purpose nonce randomize cipher protect gainst re-use attacks. way can use one secret encrypting multiple messages. data_tag function generates authenticated hash can stored alongside data able verify integrity data later . public key signatures see sig_sign instead.","code":""},{"path":"https://docs.ropensci.org/sodium/reference/symmetric.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Symmetric Encryption and Tagging — Symmetric encryption","text":"https://libsodium.gitbook.io/doc/public-key_cryptography/authenticated_encryption","code":""},{"path":"https://docs.ropensci.org/sodium/reference/symmetric.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Symmetric Encryption and Tagging — Symmetric encryption","text":"","code":"# 256-bit key key <- sha256(charToRaw(\"This is a secret passphrase\")) msg <- serialize(iris, NULL)  # Encrypts with random nonce cipher <- data_encrypt(msg, key) orig <- data_decrypt(cipher, key) stopifnot(identical(msg, orig))  # Tag the message with your key (HMAC) tag <- data_tag(msg, key)"}]
